[{"name":"app.R","content":"library(shiny)\nlibrary(bslib)\n\n# ─── Load Concept Data ────────────────────────────────────────────────────────\n\nconcepts_df <- read.csv(\"neuro_concepts.csv\", stringsAsFactors = FALSE)\nconcepts_by_level <- split(concepts_df, concepts_df$level)\nall_levels <- sort(unique(concepts_df$level))\nmax_level <- max(all_levels)\n\nmessage(\"Loaded \", nrow(concepts_df), \" concepts across \", length(all_levels), \" levels\")\n\n# ─── Milestone Descriptions ──────────────────────────────────────────────────\n\nmilestone_texts <- list(\n  \"2\"    = \"Neurotransmitters are chemical messengers that carry signals between neurons. They are the fundamental currency of brain communication.\",\n  \"4\"    = \"Receptors are proteins on cell surfaces that detect neurotransmitters. Each receptor type responds to specific chemicals, enabling precise signalling.\",\n  \"8\"    = \"Synaptic processes govern how signals are transmitted, strengthened, or weakened at the junction between neurons. They underlie all learning and adaptation.\",\n  \"16\"   = \"Different cell types form the building blocks of neural tissue. Each type has specialised roles \\u2014 from excitatory projection to local inhibition to structural support.\",\n  \"32\"   = \"Neural circuits are interconnected pathways that process specific types of information \\u2014 reward, fear, habit, memory. They turn cellular activity into function.\",\n  \"64\"   = \"Brain structures are anatomically distinct regions, each contributing to particular functions. Damage to a structure often reveals its role.\",\n  \"128\"  = \"Brain regions group structures into larger functional systems. The limbic system handles emotion; the cortex handles higher cognition; the brainstem keeps you alive.\",\n  \"256\"  = \"Large-scale networks coordinate activity across distant brain regions. The default mode network activates during rest; the central executive engages during focused tasks.\",\n  \"512\"  = \"Functional systems integrate multiple networks to produce complex capacities \\u2014 movement, memory, attention, emotion, and language.\",\n  \"1024\" = \"At the highest level, the brain produces cognition, perception, action, and affect \\u2014 the broad categories that encompass all mental life.\",\n  \"2048\" = \"You\\u2019ve built the brain! From individual neurotransmitters to the integrated organ of mind \\u2014 every level depends on the ones below it.\"\n)\n\n# ─── Tile Colour Palette ─────────────────────────────────────────────────────\n\nlevel_colours <- list(\n  \"0\"    = list(bg = \"#e0dae8\", fg = \"#e0dae8\"),\n  \"2\"    = list(bg = \"#7ec8e3\", fg = \"#1a3a4a\"),\n  \"4\"    = list(bg = \"#5ba3cf\", fg = \"#ffffff\"),\n  \"8\"    = list(bg = \"#4a90d9\", fg = \"#ffffff\"),\n  \"16\"   = list(bg = \"#7b68ae\", fg = \"#ffffff\"),\n  \"32\"   = list(bg = \"#9b59b6\", fg = \"#ffffff\"),\n  \"64\"   = list(bg = \"#c0392b\", fg = \"#ffffff\"),\n  \"128\"  = list(bg = \"#e67e22\", fg = \"#ffffff\"),\n  \"256\"  = list(bg = \"#f1c40f\", fg = \"#3a3348\"),\n  \"512\"  = list(bg = \"#27ae60\", fg = \"#ffffff\"),\n  \"1024\" = list(bg = \"#1abc9c\", fg = \"#ffffff\"),\n  \"2048\" = list(bg = \"#e74c8c\", fg = \"#ffffff\")\n)\n\nget_tile_colours <- function(level) {\n  key <- as.character(level)\n  if (key %in% names(level_colours)) level_colours[[key]]\n  else list(bg = \"#e74c8c\", fg = \"#ffffff\")\n}\n\n# ─── Helper Functions ─────────────────────────────────────────────────────────\n\nrandom_concept <- function(level) {\n  pool <- concepts_by_level[[as.character(level)]]\n  if (is.null(pool) || nrow(pool) == 0L) return(NULL)\n  row <- pool[sample.int(nrow(pool), 1L), , drop = FALSE]\n  list(\n    level       = as.integer(row$level),\n    label       = as.character(row$label),\n    short_label = as.character(row$short_label),\n    tooltip     = as.character(row$tooltip),\n    category    = as.character(row$category)\n  )\n}\n\n# Generate 4 classification options (1 correct + 3 adjacent distractors)\nmake_classify_options <- function(correct_level) {\n  correct_cat <- concepts_by_level[[as.character(correct_level)]]$category[1]\n  all_cats <- vapply(all_levels, function(l) {\n    concepts_by_level[[as.character(l)]]$category[1]\n  }, character(1))\n\n  # Find index of correct level\n  idx <- which(all_levels == correct_level)\n\n  # Pick distractor indices: nearest levels first, expanding outward\n  offsets <- c(-1, 1, -2, 2, -3, 3, -4, 4, -5, 5)\n  distractor_cats <- character(0)\n  for (off in offsets) {\n    didx <- idx + off\n    if (didx >= 1L && didx <= length(all_levels)) {\n      cat <- all_cats[didx]\n      if (cat != correct_cat && !(cat %in% distractor_cats)) {\n        distractor_cats <- c(distractor_cats, cat)\n      }\n    }\n    if (length(distractor_cats) >= 3L) break\n  }\n\n  # If we somehow have fewer than 3, pad from remaining\n  remaining <- setdiff(all_cats, c(correct_cat, distractor_cats))\n  if (length(distractor_cats) < 3L && length(remaining) > 0L) {\n    need <- 3L - length(distractor_cats)\n    distractor_cats <- c(distractor_cats, sample(remaining, min(need, length(remaining))))\n  }\n\n  opts <- c(correct_cat, distractor_cats[1:3])\n  sample(opts)  # Shuffle\n}\n\n# ─── Game Logic ───────────────────────────────────────────────────────────────\n\nempty_board <- function() vector(\"list\", 16)\ncell_idx <- function(r, c) (r - 1L) * 4L + c\n\nadd_random_tile <- function(board) {\n  empty_pos <- which(vapply(board, is.null, logical(1)))\n  if (length(empty_pos) == 0L) return(list(board = board, pos = NULL))\n  pos <- if (length(empty_pos) == 1L) empty_pos else sample(empty_pos, 1L)\n  spawn_level <- if (runif(1) < 0.9) 2L else 4L\n  board[[pos]] <- random_concept(spawn_level)\n  list(board = board, pos = pos)\n}\n\nslide_row_left <- function(row) {\n  non_null <- Filter(Negate(is.null), row)\n  if (length(non_null) == 0L) {\n    return(list(row = vector(\"list\", 4), score = 0L, merge_info = NULL))\n  }\n  merged <- list()\n  pts <- 0L\n  merge_info <- NULL\n  i <- 1L\n  while (i <= length(non_null)) {\n    if (i < length(non_null) && non_null[[i]]$level == non_null[[i + 1L]]$level) {\n      next_level <- min(non_null[[i]]$level * 2L, max_level)\n      new_concept <- random_concept(next_level)\n      merged <- c(merged, list(new_concept))\n      pts <- pts + next_level\n      if (is.null(merge_info)) {\n        merge_info <- list(\n          from_category = non_null[[i]]$category,\n          to_category   = new_concept$category,\n          to_concept    = new_concept$label\n        )\n      }\n      i <- i + 2L\n    } else {\n      merged <- c(merged, list(non_null[[i]]))\n      i <- i + 1L\n    }\n  }\n  while (length(merged) < 4L) merged <- c(merged, list(NULL))\n  list(row = merged, score = pts, merge_info = merge_info)\n}\n\nmove_board <- function(board, direction) {\n  total_score <- 0L\n  last_merge_info <- NULL\n  nb <- vector(\"list\", 16)\n  for (k in 1:16) nb[k] <- list(board[[k]])\n\n  if (direction == \"left\") {\n    for (r in 1:4) {\n      row <- list(nb[[cell_idx(r,1)]], nb[[cell_idx(r,2)]],\n                  nb[[cell_idx(r,3)]], nb[[cell_idx(r,4)]])\n      res <- slide_row_left(row)\n      for (c in 1:4) nb[cell_idx(r, c)] <- list(res$row[[c]])\n      total_score <- total_score + res$score\n      if (!is.null(res$merge_info)) last_merge_info <- res$merge_info\n    }\n  } else if (direction == \"right\") {\n    for (r in 1:4) {\n      row <- list(nb[[cell_idx(r,4)]], nb[[cell_idx(r,3)]],\n                  nb[[cell_idx(r,2)]], nb[[cell_idx(r,1)]])\n      res <- slide_row_left(row)\n      nb[cell_idx(r,4)] <- list(res$row[[1]])\n      nb[cell_idx(r,3)] <- list(res$row[[2]])\n      nb[cell_idx(r,2)] <- list(res$row[[3]])\n      nb[cell_idx(r,1)] <- list(res$row[[4]])\n      total_score <- total_score + res$score\n      if (!is.null(res$merge_info)) last_merge_info <- res$merge_info\n    }\n  } else if (direction == \"up\") {\n    for (c in 1:4) {\n      col <- list(nb[[cell_idx(1,c)]], nb[[cell_idx(2,c)]],\n                  nb[[cell_idx(3,c)]], nb[[cell_idx(4,c)]])\n      res <- slide_row_left(col)\n      for (r in 1:4) nb[cell_idx(r, c)] <- list(res$row[[r]])\n      total_score <- total_score + res$score\n      if (!is.null(res$merge_info)) last_merge_info <- res$merge_info\n    }\n  } else if (direction == \"down\") {\n    for (c in 1:4) {\n      col <- list(nb[[cell_idx(4,c)]], nb[[cell_idx(3,c)]],\n                  nb[[cell_idx(2,c)]], nb[[cell_idx(1,c)]])\n      res <- slide_row_left(col)\n      nb[cell_idx(4,c)] <- list(res$row[[1]])\n      nb[cell_idx(3,c)] <- list(res$row[[2]])\n      nb[cell_idx(2,c)] <- list(res$row[[3]])\n      nb[cell_idx(1,c)] <- list(res$row[[4]])\n      total_score <- total_score + res$score\n      if (!is.null(res$merge_info)) last_merge_info <- res$merge_info\n    }\n  }\n  list(board = nb, score = total_score, merge_info = last_merge_info)\n}\n\nboards_equal <- function(a, b) {\n  if (length(a) != 16L || length(b) != 16L) return(FALSE)\n  for (i in 1:16) {\n    a_null <- is.null(a[[i]])\n    b_null <- is.null(b[[i]])\n    if (a_null && b_null) next\n    if (a_null || b_null) return(FALSE)\n    if (a[[i]]$level != b[[i]]$level ||\n        a[[i]]$short_label != b[[i]]$short_label) return(FALSE)\n  }\n  TRUE\n}\n\ncan_move <- function(board) {\n  for (r in 1:4) {\n    for (c in 1:4) {\n      idx <- cell_idx(r, c)\n      if (is.null(board[[idx]])) return(TRUE)\n      if (c < 4L) {\n        adj <- cell_idx(r, c + 1L)\n        if (!is.null(board[[adj]]) &&\n            board[[idx]]$level == board[[adj]]$level) return(TRUE)\n      }\n      if (r < 4L) {\n        adj <- cell_idx(r + 1L, c)\n        if (!is.null(board[[adj]]) &&\n            board[[idx]]$level == board[[adj]]$level) return(TRUE)\n      }\n    }\n  }\n  FALSE\n}\n\nhas_won <- function(board) {\n  for (i in 1:16) {\n    if (!is.null(board[[i]]) && board[[i]]$level >= max_level) return(TRUE)\n  }\n  FALSE\n}\n\nmake_starting_board <- function() {\n  board <- empty_board()\n  res1 <- add_random_tile(board)\n  board <- res1$board\n  res2 <- add_random_tile(board)\n  res2$board\n}\n\ncollect_discovered <- function(board) {\n  disc <- list()\n  for (i in 1:16) {\n    cell <- board[[i]]\n    if (!is.null(cell)) {\n      lvl <- as.character(cell$level)\n      if (is.null(disc[[lvl]])) disc[[lvl]] <- character(0)\n      if (!(cell$short_label %in% disc[[lvl]])) {\n        disc[[lvl]] <- c(disc[[lvl]], cell$short_label)\n      }\n    }\n  }\n  disc\n}\n\nhighest_level_on_board <- function(board) {\n  max_found <- 0L\n  for (i in 1:16) {\n    if (!is.null(board[[i]])) max_found <- max(max_found, board[[i]]$level)\n  }\n  max_found\n}\n\n# ─── CSS ──────────────────────────────────────────────────────────────────────\n\ngame_css <- \"\nhtml, body {\n  overflow-x: hidden; touch-action: none;\n  user-select: none; -webkit-user-select: none;\n}\n.app-container { max-width: 500px; margin: 0 auto; padding: 0.5rem; }\n.game-header {\n  display: flex; justify-content: space-between;\n  align-items: center; margin-bottom: 0.5rem;\n}\n.game-title { font-size: 1.6rem; font-weight: 800; color: #4a4458; line-height: 1.1; }\n.game-title small {\n  display: block; font-size: 0.7rem; font-weight: 400;\n  color: #8a8498; letter-spacing: 0.04em;\n}\n.scores-container { display: flex; gap: 0.4rem; }\n.score-box {\n  background: #6b5b95; border-radius: 6px;\n  padding: 0.3rem 0.9rem; text-align: center; min-width: 65px;\n}\n.score-label {\n  font-size: 0.6rem; font-weight: 700; color: rgba(255,255,255,0.7);\n  text-transform: uppercase; letter-spacing: 0.05em;\n}\n.score-value { font-size: 1.2rem; font-weight: 700; color: white; line-height: 1.2; }\n.subtitle-row {\n  display: flex; justify-content: space-between;\n  align-items: center; margin-bottom: 0.5rem;\n}\n.game-subtitle { font-size: 0.85rem; color: #6b5b95; }\n.btn-game {\n  background: #6b5b95; color: #f9f6f2; border: none;\n  border-radius: 6px; padding: 0.45rem 1rem; font-weight: 700;\n  font-size: 0.8rem; cursor: pointer; transition: background 0.15s;\n}\n.btn-game:hover { background: #7d6da8; color: #f9f6f2; }\n\n/* ── Board ─────────────────────────────────────── */\n.board-container {\n  background: #d8d0e4; border-radius: 8px; padding: 8px;\n  position: relative; overflow: visible;\n}\n.board-grid {\n  display: grid; grid-template-columns: repeat(4, 1fr);\n  gap: 8px; overflow: visible;\n}\n.tile {\n  aspect-ratio: 1; display: flex; flex-direction: column;\n  align-items: center; justify-content: center;\n  border-radius: 6px; font-weight: 700; position: relative;\n  cursor: default; line-height: 1.1;\n}\n.tile-label { z-index: 1; text-align: center; padding: 0 2px; }\n.tile-new { animation: tile-pop 0.25s ease-in-out; }\n.tile-merged { animation: tile-pulse 0.3s ease-in-out; }\n@keyframes tile-pop {\n  0%{transform:scale(0)} 50%{transform:scale(1.1)} 100%{transform:scale(1)}\n}\n@keyframes tile-pulse {\n  0%{transform:scale(1)} 30%{transform:scale(1.12)} 100%{transform:scale(1)}\n}\n\n/* Level indicator in corner */\n.tile-level-num {\n  position: absolute; bottom: 3px; right: 5px;\n  font-size: 0.65rem; opacity: 0.65; font-weight: 700;\n  z-index: 1;\n}\n\n/* ── Tooltips ──────────────────────────────────── */\n.tile-tooltip {\n  display: none; position: absolute;\n  left: 50%; transform: translateX(-50%);\n  background: #3a3348; color: white;\n  font-size: 0.65rem; font-weight: 400;\n  padding: 0.35rem 0.6rem; border-radius: 5px; z-index: 150;\n  max-width: 200px; text-align: center; pointer-events: none;\n  box-shadow: 0 2px 8px rgba(0,0,0,0.2); white-space: normal;\n}\n.tile-tooltip { bottom: calc(100% + 6px); }\n.tile-tooltip::after {\n  content:''; position: absolute; top: 100%; left: 50%;\n  transform: translateX(-50%); border: 5px solid transparent;\n  border-top-color: #3a3348;\n}\n.tile-row-1 .tile-tooltip { bottom: auto; top: calc(100% + 6px); }\n.tile-row-1 .tile-tooltip::after {\n  top: auto; bottom: 100%;\n  border-top-color: transparent; border-bottom-color: #3a3348;\n}\n.tile:hover .tile-tooltip, .tile:active .tile-tooltip { display: block; }\n\n/* ── Overlays ──────────────────────────────────── */\n.game-overlay {\n  position: absolute; inset: 0; background: rgba(216,208,228,0.8);\n  border-radius: 8px; display: flex; flex-direction: column;\n  align-items: center; justify-content: center;\n  z-index: 100; animation: fade-in 0.5s ease; gap: 0.6rem;\n}\n.game-overlay.win-overlay { background: rgba(107,91,149,0.6); }\n.overlay-title { font-size: 2.2rem; font-weight: 800; color: #4a4458; }\n.win-overlay .overlay-title { color: white; }\n.overlay-buttons { display: flex; gap: 0.5rem; }\n@keyframes fade-in { from{opacity:0} to{opacity:1} }\n\n/* Onboarding overlay */\n.onboarding-overlay {\n  position: absolute; inset: 0;\n  background: rgba(74, 68, 88, 0.92);\n  border-radius: 8px; display: flex; flex-direction: column;\n  align-items: center; justify-content: center;\n  z-index: 200; padding: 1.5rem; text-align: center;\n  animation: fade-in 0.4s ease;\n}\n.onboarding-overlay h3 { color: white; font-size: 1.3rem; font-weight: 800; margin-bottom: 0.6rem; }\n.onboarding-overlay p { color: rgba(255,255,255,0.85); font-size: 0.78rem; line-height: 1.5; margin-bottom: 0.4rem; max-width: 320px; }\n.onboard-hint { display: flex; align-items: center; gap: 0.6rem; margin: 0.4rem 0; justify-content: center; }\n.onboard-swatch {\n  width: 28px; height: 28px; border-radius: 4px;\n  display: inline-flex; align-items: center; justify-content: center;\n  font-size: 0.55rem; font-weight: 700; color: white;\n}\n.onboard-plus { color: rgba(255,255,255,0.6); font-size: 1rem; font-weight: 700; }\n.onboard-arrow { color: rgba(255,255,255,0.6); font-size: 1rem; }\n\n/* ── Classification Challenge ──────────────────── */\n.classify-overlay {\n  position: absolute; inset: 0;\n  background: rgba(130, 130, 130, 0.95);\n  border-radius: 8px; display: flex; flex-direction: column;\n  align-items: center; justify-content: center;\n  z-index: 250; padding: 1rem; text-align: center;\n  animation: fade-in 0.25s ease;\n}\n.classify-prompt {\n  font-size: 0.75rem; font-weight: 700; color: rgba(255,255,255,0.7);\n  text-transform: uppercase; letter-spacing: 0.05em;\n  margin-bottom: 0.6rem;\n}\n.classify-tile {\n  width: 90px; height: 90px;\n  background: #555;\n  border-radius: 8px;\n  display: flex; flex-direction: column;\n  align-items: center; justify-content: center;\n  margin-bottom: 0.8rem;\n  box-shadow: 0 4px 16px rgba(0,0,0,0.3);\n}\n.classify-tile-label {\n  font-size: 1.3rem; font-weight: 800; color: white;\n}\n.classify-tile-sublabel {\n  font-size: 0.6rem; color: rgba(255,255,255,0.7);\n  margin-top: 0.15rem;\n}\n.classify-question {\n  font-size: 0.85rem; font-weight: 700; color: white;\n  margin-bottom: 0.5rem;\n}\n.classify-options {\n  display: grid; grid-template-columns: 1fr 1fr;\n  gap: 0.4rem; width: 100%; max-width: 300px;\n}\n.classify-btn {\n  background: rgba(255,255,255,0.15); color: white;\n  border: 2px solid rgba(255,255,255,0.3);\n  border-radius: 8px; padding: 0.5rem 0.3rem;\n  font-weight: 700; font-size: 0.75rem;\n  cursor: pointer; transition: all 0.15s;\n  font-family: inherit;\n}\n.classify-btn:hover {\n  background: rgba(255,255,255,0.25);\n  border-color: rgba(255,255,255,0.6);\n}\n.classify-btn.correct-answer {\n  background: rgba(39, 174, 96, 0.6) !important;\n  border-color: #27ae60 !important;\n  animation: pulse-correct 0.4s ease;\n}\n.classify-btn.wrong-answer {\n  background: rgba(192, 57, 43, 0.5) !important;\n  border-color: #c0392b !important;\n}\n@keyframes pulse-correct {\n  0%{transform:scale(1)} 50%{transform:scale(1.05)} 100%{transform:scale(1)}\n}\n.classify-feedback {\n  font-size: 0.75rem; font-weight: 700; margin-top: 0.4rem;\n  min-height: 1.2rem;\n}\n.classify-feedback.correct { color: #2ecc71; }\n.classify-feedback.wrong { color: #e74c3c; }\n.classify-penalty {\n  font-size: 0.6rem; color: rgba(255,255,255,0.5);\n  margin-top: 0.15rem;\n}\n\n/* Milestone banner */\n.milestone-banner {\n  position: fixed; top: 0; left: 0; right: 0;\n  background: linear-gradient(135deg, #6b5b95, #4a4458);\n  color: white; z-index: 300; padding: 0.8rem 1rem;\n  animation: milestone-slide-in 0.4s ease-out, milestone-slide-out 0.4s ease-in 4.6s forwards;\n  box-shadow: 0 4px 20px rgba(0,0,0,0.3);\n}\n.milestone-inner { max-width: 500px; margin: 0 auto; text-align: center; }\n.milestone-badge {\n  display: inline-block; padding: 0.15rem 0.6rem;\n  border-radius: 4px; font-size: 0.6rem; font-weight: 700;\n  text-transform: uppercase; letter-spacing: 0.06em; margin-bottom: 0.3rem;\n}\n.milestone-category { font-size: 1.1rem; font-weight: 800; margin-bottom: 0.25rem; }\n.milestone-desc { font-size: 0.72rem; line-height: 1.5; opacity: 0.9; }\n@keyframes milestone-slide-in { from{transform:translateY(-100%)} to{transform:translateY(0)} }\n@keyframes milestone-slide-out { from{transform:translateY(0);opacity:1} to{transform:translateY(-100%);opacity:0} }\n\n/* Merge toast */\n.merge-toast {\n  position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%);\n  background: #6b5b95; color: white; padding: 0.4rem 1rem;\n  border-radius: 8px; font-size: 0.8rem; font-weight: 700; z-index: 200;\n  animation: toast-fade-in 0.25s ease-out, toast-fade-out 0.25s ease-in 1.2s forwards;\n  box-shadow: 0 4px 16px rgba(107,91,149,0.4); text-align: center;\n}\n.merge-detail { font-size: 0.7rem; font-weight: 400; opacity: 0.85; margin-top: 0.1rem; }\n@keyframes toast-fade-in { from{opacity:0;transform:translateX(-50%) translateY(0.5rem)} to{opacity:1;transform:translateX(-50%) translateY(0)} }\n@keyframes toast-fade-out { from{opacity:1} to{opacity:0} }\n\n/* ── Progress Tracker ──────────────────────────── */\n.progress-tracker {\n  margin-top: 0.6rem; background: white;\n  border-radius: 8px; padding: 0.6rem 0.75rem;\n}\n.progress-title {\n  font-size: 0.7rem; font-weight: 700; color: #6b5b95;\n  text-transform: uppercase; letter-spacing: 0.04em; margin-bottom: 0.4rem;\n}\n.progress-levels { display: flex; gap: 4px; flex-wrap: wrap; }\n.progress-level {\n  display: flex; flex-direction: column; align-items: center; flex: 1; min-width: 0;\n}\n.progress-bar-segment {\n  height: 6px; width: 100%; border-radius: 3px;\n  background: #e8e4ee; overflow: hidden;\n}\n.progress-bar-fill { height: 100%; border-radius: 3px; }\n.progress-category {\n  font-size: 0.45rem; color: #8a8498; text-align: center;\n  margin-top: 2px; line-height: 1.1; font-weight: 700; text-transform: uppercase;\n}\n.progress-fraction { font-size: 0.45rem; color: #aaa0b8; }\n\n/* Discovery Log */\n.discovery-log { margin-top: 0.5rem; background: white; border-radius: 8px; overflow: hidden; }\n.discovery-toggle {\n  width: 100%; background: none; border: none;\n  padding: 0.5rem 0.75rem; cursor: pointer;\n  display: flex; justify-content: space-between; align-items: center;\n  font-family: inherit;\n}\n.discovery-toggle:hover { background: #f8f6f0; }\n.discovery-toggle-label { font-size: 0.7rem; font-weight: 700; color: #6b5b95; text-transform: uppercase; letter-spacing: 0.04em; }\n.discovery-toggle-arrow { font-size: 0.7rem; color: #6b5b95; transition: transform 0.2s; }\n.discovery-toggle-arrow.open { transform: rotate(180deg); }\n.discovery-content { padding: 0 0.75rem 0.6rem 0.75rem; max-height: 300px; overflow-y: auto; }\n.discovery-level-group { margin-bottom: 0.5rem; }\n.discovery-level-header {\n  font-size: 0.65rem; font-weight: 700; text-transform: uppercase;\n  letter-spacing: 0.03em; margin-bottom: 0.25rem;\n  padding: 0.15rem 0.4rem; border-radius: 3px; display: inline-block;\n}\n.discovery-item { font-size: 0.68rem; color: #4a4458; padding: 0.2rem 0; border-bottom: 1px solid #f0ecf4; line-height: 1.4; }\n.discovery-item:last-child { border-bottom: none; }\n.discovery-item strong { font-weight: 700; }\n.discovery-item .disc-tooltip { color: #8a8498; font-size: 0.6rem; }\n.discovery-empty { font-size: 0.7rem; color: #aaa0b8; font-style: italic; padding: 0.3rem 0; }\n\n/* Instructions / Footer */\n.instructions { text-align: center; margin-top: 0.5rem; font-size: 0.7rem; color: #aaa0b8; }\nkbd { background: #6b5b95; color: white; padding: 0.1rem 0.4rem; border-radius: 3px; font-size: 0.65rem; font-weight: 700; }\n\"\n\n# ─── JavaScript ───────────────────────────────────────────────────────────────\n\ngame_js <- '\ndocument.addEventListener(\"keydown\", function(e) {\n  var m = {ArrowUp:\"up\",ArrowDown:\"down\",ArrowLeft:\"left\",ArrowRight:\"right\",\n           w:\"up\",s:\"down\",a:\"left\",d:\"right\"};\n  if (m[e.key]) { e.preventDefault(); Shiny.setInputValue(\"move_dir\", m[e.key], {priority:\"event\"}); }\n});\nvar tx=null, ty=null;\ndocument.addEventListener(\"touchstart\", function(e) {\n  tx=e.touches[0].clientX; ty=e.touches[0].clientY;\n}, {passive:true});\ndocument.addEventListener(\"touchend\", function(e) {\n  if(tx===null) return;\n  var dx=e.changedTouches[0].clientX-tx, dy=e.changedTouches[0].clientY-ty;\n  var ax=Math.abs(dx), ay=Math.abs(dy);\n  if(Math.max(ax,ay)<30) return;\n  Shiny.setInputValue(\"move_dir\",\n    ax>ay ? (dx>0?\"right\":\"left\") : (dy>0?\"down\":\"up\"), {priority:\"event\"});\n  tx=ty=null;\n}, {passive:true});\nShiny.addCustomMessageHandler(\"milestone\", function(msg) {\n  document.querySelectorAll(\".milestone-banner\").forEach(function(t){t.remove();});\n  var d = document.createElement(\"div\");\n  d.className = \"milestone-banner\";\n  d.innerHTML = \"<div class=\\\\\"milestone-inner\\\\\">\" +\n    \"<div class=\\\\\"milestone-badge\\\\\" style=\\\\\"background:\" + msg.colour + \";\\\\\">\\\\u2B50 Level Unlocked<\/div>\" +\n    \"<div class=\\\\\"milestone-category\\\\\">\" + msg.category + \"<\/div>\" +\n    \"<div class=\\\\\"milestone-desc\\\\\">\" + msg.desc + \"<\/div><\/div>\";\n  document.body.appendChild(d);\n  setTimeout(function(){if(d.parentNode) d.remove();}, 5000);\n});\nShiny.addCustomMessageHandler(\"merge_toast\", function(msg) {\n  document.querySelectorAll(\".merge-toast\").forEach(function(t){t.remove();});\n  var d = document.createElement(\"div\");\n  d.className = \"merge-toast\";\n  d.innerHTML = msg.from + \" \\\\u2192 <strong>\" + msg.to + \"<\/strong>\" +\n    \"<div class=\\\\\"merge-detail\\\\\">Discovered: \" + msg.concept + \"<\/div>\";\n  document.body.appendChild(d);\n  setTimeout(function(){if(d.parentNode) d.remove();}, 1500);\n});\nShiny.addCustomMessageHandler(\"js_eval\", function(msg) {\n  try { eval(msg); } catch(e) {}\n});\n'\n\n# ─── UI ───────────────────────────────────────────────────────────────────────\n\nui <- page_fillable(\n  theme = bs_theme(\n    bg = \"#f5f0e8\", fg = \"#4a4458\",\n    base_font = font_collection(\"Nunito Sans\", \"Helvetica Neue\", \"Arial\", \"sans-serif\"),\n    heading_font = font_collection(\"Nunito Sans\", \"Helvetica Neue\", \"Arial\", \"sans-serif\")\n  ),\n  tags$head(\n    tags$link(rel = \"stylesheet\",\n              href = \"https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;700;800&display=swap\"),\n    tags$style(HTML(game_css)),\n    tags$script(HTML(game_js))\n  ),\n\n  div(class = \"app-container\",\n    div(class = \"game-header\",\n      div(class = \"game-title\", \"Concept Merge\",\n          tags$small(\"From Neurotransmitters to The Brain\")),\n      div(class = \"scores-container\",\n        div(class = \"score-box\",\n            div(class = \"score-label\", \"Score\"),\n            div(class = \"score-value\", textOutput(\"score_text\", inline = TRUE))),\n        div(class = \"score-box\",\n            div(class = \"score-label\", \"Best\"),\n            div(class = \"score-value\", textOutput(\"best_text\", inline = TRUE)))\n      )\n    ),\n    div(class = \"subtitle-row\",\n      tags$p(class = \"game-subtitle\", \"Merge same-level concepts to build the brain!\"),\n      actionButton(\"new_game\", \"New Game\", class = \"btn-game\")\n    ),\n    div(class = \"board-container\",\n      uiOutput(\"board_ui\"),\n      uiOutput(\"overlay_ui\"),\n      uiOutput(\"onboarding_ui\"),\n      uiOutput(\"classify_ui\")\n    ),\n    div(class = \"progress-tracker\",\n      div(class = \"progress-title\", \"Concepts Discovered\"),\n      uiOutput(\"progress_ui\")\n    ),\n    div(class = \"discovery-log\",\n      actionButton(\"toggle_log\",\n        label = tagList(\n          span(class = \"discovery-toggle-label\", \"Discovery Log\"),\n          span(class = \"discovery-toggle-arrow\", id = \"log-arrow\", \"\\u25BC\")\n        ),\n        class = \"discovery-toggle\"\n      ),\n      uiOutput(\"discovery_log_ui\")\n    ),\n    div(class = \"instructions\",\n      \"Use \", tags$kbd(\"\\u2190\"), tags$kbd(\"\\u2191\"),\n      tags$kbd(\"\\u2193\"), tags$kbd(\"\\u2192\"),\n      \" or \", tags$kbd(\"W\"), tags$kbd(\"A\"),\n      tags$kbd(\"S\"), tags$kbd(\"D\"),\n      \" to move \\u2022 Swipe on mobile \\u2022 Hover tiles for info\"\n    ),\n    div(style = \"text-align:center; margin-top:0.6rem; font-size:0.6rem; color:#aaa0b8;\",\n      \"Built with \",\n      tags$a(href = \"https://shiny.posit.co/\", target = \"_blank\",\n             style = \"color:#6b5b95;\", \"Shiny\"),\n      \" + \",\n      tags$a(href = \"https://shinylive.io/\", target = \"_blank\",\n             style = \"color:#6b5b95;\", \"Shinylive\"),\n      \" | \",\n      tags$a(href = \"https://tvpollet.github.io/disclaimer\", target = \"_blank\",\n             style = \"color:#6b5b95;\", \"Disclaimer\")\n    )\n  )\n)\n\n# ─── Server ───────────────────────────────────────────────────────────────────\n\nserver <- function(input, output, session) {\n\n  init_board <- make_starting_board()\n\n  gs <- reactiveValues(\n    board            = init_board,\n    score            = 0L,\n    best             = 0L,\n    game_over        = FALSE,\n    won              = FALSE,\n    keep_playing     = FALSE,\n    new_tiles        = integer(0),\n    merged_tiles     = integer(0),\n    discovered       = collect_discovered(init_board),\n    all_discovered   = collect_discovered(init_board),\n    highest_level    = highest_level_on_board(init_board),\n    show_onboarding  = TRUE,\n    log_open         = FALSE,\n    # Classification state\n    classified       = character(0),  # short_labels player has classified\n    classify_queue   = list(),        # list of concept objects awaiting classification\n    classifying      = FALSE,\n    current_classify = NULL,          # current concept being classified\n    classify_options = character(0),  # 4 category options\n    classify_feedback = NULL,         # NULL / \"correct\" / \"wrong\"\n    classify_correct_cat = \"\",        # for highlighting after wrong answer\n    classify_advance_at = NULL,       # Sys.time() when to auto-advance\n    # Pending state: move results held until classification done\n    pending_merge_info = NULL,\n    pending_highest    = 0L\n  )\n\n  merge_discoveries <- function(existing, new_disc) {\n    for (lvl in names(new_disc)) {\n      if (is.null(existing[[lvl]])) existing[[lvl]] <- new_disc[[lvl]]\n      else existing[[lvl]] <- unique(c(existing[[lvl]], new_disc[[lvl]]))\n    }\n    existing\n  }\n\n  # Start classification for next item in queue\n  start_next_classify <- function() {\n    if (length(gs$classify_queue) == 0L) {\n      gs$classifying <- FALSE\n      gs$current_classify <- NULL\n      gs$classify_feedback <- NULL\n\n      # Fire pending milestone/toast now that classification is done\n      if (!is.null(gs$pending_merge_info)) {\n        session$sendCustomMessage(\"merge_toast\", list(\n          from = gs$pending_merge_info$from_category,\n          to = gs$pending_merge_info$to_category,\n          concept = gs$pending_merge_info$to_concept\n        ))\n        gs$pending_merge_info <- NULL\n      }\n      if (gs$pending_highest > gs$highest_level) {\n        gs$highest_level <- gs$pending_highest\n        lvl_chr <- as.character(gs$pending_highest)\n        tc <- get_tile_colours(gs$pending_highest)\n        cat_name <- concepts_by_level[[lvl_chr]]$category[1]\n        desc <- milestone_texts[[lvl_chr]]\n        if (!is.null(desc)) {\n          session$sendCustomMessage(\"milestone\", list(\n            category = cat_name, desc = desc, colour = tc$bg\n          ))\n        }\n      }\n      gs$pending_highest <- 0L\n      return()\n    }\n\n    concept <- gs$classify_queue[[1]]\n    gs$classify_queue <- gs$classify_queue[-1]\n    gs$current_classify <- concept\n    gs$classify_options <- make_classify_options(concept$level)\n    gs$classify_feedback <- NULL\n    gs$classify_correct_cat <- concept$category\n    gs$classifying <- TRUE\n  }\n\n  # ── New Game ──────────────────────────────────────────────────────────────\n\n  do_new_game <- function() {\n    b <- make_starting_board()\n    gs$board           <- b\n    gs$score           <- 0L\n    gs$game_over       <- FALSE\n    gs$won             <- FALSE\n    gs$keep_playing    <- FALSE\n    gs$new_tiles       <- integer(0)\n    gs$merged_tiles    <- integer(0)\n    gs$discovered      <- collect_discovered(b)\n    gs$all_discovered  <- merge_discoveries(gs$all_discovered, gs$discovered)\n    gs$highest_level   <- highest_level_on_board(b)\n    gs$show_onboarding <- FALSE\n    gs$classified      <- character(0)\n    gs$classify_queue  <- list()\n    gs$classifying     <- FALSE\n    gs$current_classify <- NULL\n    gs$classify_feedback <- NULL\n    gs$pending_merge_info <- NULL\n    gs$classify_advance_at <- NULL\n    gs$pending_highest <- 0L\n\n    # Queue initial tiles for classification\n    new_concepts <- list()\n    for (i in 1:16) {\n      cell <- b[[i]]\n      if (!is.null(cell) && !(cell$short_label %in% gs$classified)) {\n        new_concepts <- c(new_concepts, list(cell))\n        gs$classified <- c(gs$classified, cell$short_label)\n      }\n    }\n    if (length(new_concepts) > 0L) {\n      gs$classify_queue <- new_concepts\n      start_next_classify()\n    }\n  }\n\n  observeEvent(input$new_game,         { do_new_game() })\n  observeEvent(input$new_game_ov,      { do_new_game() })\n  observeEvent(input$new_game_ov2,     { do_new_game() })\n  observeEvent(input$keep_playing_btn, { gs$keep_playing <- TRUE; gs$won <- FALSE })\n  observeEvent(input$dismiss_onboard,  { gs$show_onboarding <- FALSE })\n  observeEvent(input$toggle_log,       { gs$log_open <- !gs$log_open })\n\n  # ── Classification Answer ─────────────────────────────────────────────────\n\n  observeEvent(input$classify_answer, {\n    if (!isTRUE(gs$classifying) || is.null(gs$current_classify)) return()\n    if (!is.null(gs$classify_feedback)) return()\n\n    chosen <- input$classify_answer\n    correct_cat <- gs$current_classify$category\n\n    if (chosen == correct_cat) {\n      gs$classify_feedback <- \"correct\"\n      gs$classify_advance_at <- Sys.time() + 0.7\n    } else {\n      gs$classify_feedback <- \"wrong\"\n      gs$score <- max(0L, gs$score - 5L)\n      gs$classify_advance_at <- Sys.time() + 1.5\n    }\n  })\n\n  # Auto-advance after feedback delay\n  observe({\n    if (is.null(gs$classify_feedback) || is.null(gs$classify_advance_at)) return()\n    invalidateLater(200, session)\n    if (Sys.time() >= gs$classify_advance_at) {\n      gs$classify_advance_at <- NULL\n      start_next_classify()\n    }\n  })\n\n  # ── Handle Moves ──────────────────────────────────────────────────────────\n\n  observeEvent(input$move_dir, {\n    if (is.null(gs$board) || isTRUE(gs$game_over)) return()\n    if (isTRUE(gs$won) && !isTRUE(gs$keep_playing)) return()\n    if (isTRUE(gs$show_onboarding)) return()\n    if (isTRUE(gs$classifying)) return()  # Block moves during classification\n    if (!is.list(gs$board) || length(gs$board) != 16L) return()\n\n    tryCatch({\n      prev <- vector(\"list\", 16)\n      for (i in 1:16) prev[i] <- list(gs$board[[i]])\n\n      result <- move_board(prev, input$move_dir)\n      if (boards_equal(result$board, prev)) return()\n\n      mp <- integer(0)\n      for (i in 1:16) {\n        if (!is.null(result$board[[i]]) && !is.null(prev[[i]]) &&\n            result$board[[i]]$level != prev[[i]]$level) {\n          mp <- c(mp, i)\n        }\n      }\n\n      res <- add_random_tile(result$board)\n      gs$board        <- res$board\n      gs$score        <- gs$score + result$score\n      gs$best         <- max(gs$best, gs$score)\n      gs$new_tiles    <- if (!is.null(res$pos)) res$pos else integer(0)\n      gs$merged_tiles <- mp\n\n      board_disc <- collect_discovered(res$board)\n      gs$discovered    <- board_disc\n      gs$all_discovered <- merge_discoveries(gs$all_discovered, board_disc)\n\n      # Collect unclassified concepts from this move\n      new_concepts <- list()\n      for (i in 1:16) {\n        cell <- res$board[[i]]\n        if (!is.null(cell) && !(cell$short_label %in% gs$classified)) {\n          new_concepts <- c(new_concepts, list(cell))\n          gs$classified <- c(gs$classified, cell$short_label)\n        }\n      }\n\n      # Store pending notifications\n      gs$pending_merge_info <- result$merge_info\n      gs$pending_highest <- highest_level_on_board(res$board)\n\n      # If new concepts need classification, enter classification mode\n      if (length(new_concepts) > 0L) {\n        gs$classify_queue <- new_concepts\n        start_next_classify()\n      } else {\n        # No classification needed — fire notifications immediately\n        if (!is.null(result$merge_info)) {\n          session$sendCustomMessage(\"merge_toast\", list(\n            from = result$merge_info$from_category,\n            to = result$merge_info$to_category,\n            concept = result$merge_info$to_concept\n          ))\n        }\n        new_highest <- highest_level_on_board(res$board)\n        if (new_highest > gs$highest_level) {\n          gs$highest_level <- new_highest\n          lvl_chr <- as.character(new_highest)\n          tc <- get_tile_colours(new_highest)\n          cat_name <- concepts_by_level[[lvl_chr]]$category[1]\n          desc <- milestone_texts[[lvl_chr]]\n          if (!is.null(desc)) {\n            session$sendCustomMessage(\"milestone\", list(\n              category = cat_name, desc = desc, colour = tc$bg\n            ))\n          }\n        }\n        gs$pending_merge_info <- NULL\n        gs$pending_highest <- 0L\n      }\n\n      if (has_won(gs$board) && !gs$keep_playing) gs$won <- TRUE\n      if (!can_move(gs$board)) gs$game_over <- TRUE\n    }, error = function(e) {\n      message(\"Move error: \", conditionMessage(e))\n    })\n  })\n\n  # ── Render Score ────────────────────────────────────────────────────────\n\n  output$score_text <- renderText(gs$score)\n  output$best_text  <- renderText(gs$best)\n\n  # ── Render Board ────────────────────────────────────────────────────────\n\n  output$board_ui <- renderUI({\n    board <- gs$board\n    if (is.null(board)) board <- empty_board()\n\n    tiles <- lapply(1:16, function(i) {\n      cell <- board[[i]]\n      tile_row <- ((i - 1L) %/% 4L) + 1L\n      anim <- \"\"\n      if (i %in% gs$new_tiles) anim <- \" tile-new\"\n      else if (i %in% gs$merged_tiles) anim <- \" tile-merged\"\n      row_class <- if (tile_row == 1L) \" tile-row-1\" else \"\"\n\n      if (is.null(cell)) {\n        div(class = paste0(\"tile\", anim, row_class),\n            style = paste0(\"background:\", level_colours[[\"0\"]]$bg, \";\"))\n      } else {\n        tc <- get_tile_colours(cell$level)\n        n <- nchar(cell$short_label)\n        fs <- if (n <= 3) \"0.95rem\" else if (n <= 5) \"0.8rem\" else \"0.65rem\"\n        div(class = paste0(\"tile\", anim, row_class),\n            style = paste0(\"background:\", tc$bg, \";color:\", tc$fg, \";\"),\n            div(class = \"tile-label\", style = paste0(\"font-size:\", fs, \";\"),\n                cell$short_label),\n            div(class = \"tile-level-num\", cell$level),\n            div(class = \"tile-tooltip\",\n                tags$strong(cell$label), tags$br(), cell$tooltip))\n      }\n    })\n    div(class = \"board-grid\", tiles)\n  })\n\n  # ── Render Classification Overlay ───────────────────────────────────────\n\n  output$classify_ui <- renderUI({\n    if (!isTRUE(gs$classifying) || is.null(gs$current_classify)) return(NULL)\n\n    concept <- gs$current_classify\n    opts <- gs$classify_options\n    fb <- gs$classify_feedback\n    correct_cat <- gs$classify_correct_cat\n\n    # Build option buttons\n    opt_buttons <- lapply(seq_along(opts), function(j) {\n      btn_class <- \"classify-btn\"\n      if (!is.null(fb)) {\n        if (opts[j] == correct_cat) btn_class <- \"classify-btn correct-answer\"\n        else if (fb == \"wrong\") btn_class <- \"classify-btn wrong-answer\"\n      }\n\n      disabled <- if (!is.null(fb)) \"pointer-events:none;\" else \"\"\n\n      tags$button(\n        class = btn_class,\n        style = disabled,\n        onclick = sprintf(\n          'Shiny.setInputValue(\"classify_answer\", \"%s\", {priority:\"event\"})',\n          gsub('\"', '\\\\\\\\\"', opts[j])\n        ),\n        opts[j]\n      )\n    })\n\n    # Feedback text\n    fb_div <- if (is.null(fb)) {\n      div(class = \"classify-feedback\", \"\")\n    } else if (fb == \"correct\") {\n      div(class = \"classify-feedback correct\", \"\\u2713 Correct!\")\n    } else {\n      tagList(\n        div(class = \"classify-feedback wrong\",\n            paste0(\"\\u2717 It's \", correct_cat)),\n        div(class = \"classify-penalty\", \"-5 points\")\n      )\n    }\n\n    div(class = \"classify-overlay\",\n      div(class = \"classify-prompt\", \"Classify this concept\"),\n      div(class = \"classify-tile\",\n        div(class = \"classify-tile-label\", concept$short_label),\n        div(class = \"classify-tile-sublabel\", concept$label)\n      ),\n      div(class = \"classify-question\", \"Which level does this belong to?\"),\n      div(class = \"classify-options\", opt_buttons),\n      fb_div\n    )\n  })\n\n  # ── Render Game Overlays ────────────────────────────────────────────────\n\n  output$overlay_ui <- renderUI({\n    if (isTRUE(gs$won) && !isTRUE(gs$keep_playing)) {\n      div(class = \"game-overlay win-overlay\",\n        div(class = \"overlay-title\", \"\\U0001f9e0 You Built a Brain!\"),\n        div(class = \"overlay-buttons\",\n          actionButton(\"keep_playing_btn\", \"Keep Going\", class = \"btn-game\"),\n          actionButton(\"new_game_ov\", \"New Game\", class = \"btn-game\")))\n    } else if (isTRUE(gs$game_over)) {\n      n_discovered <- sum(vapply(gs$all_discovered, length, integer(1)))\n      n_total <- nrow(concepts_df)\n      div(class = \"game-overlay\",\n        div(class = \"overlay-title\", \"Game Over\"),\n        div(style = \"font-size:0.85rem; color:#6b5b95; margin-bottom:0.4rem;\",\n            paste0(\"Concepts discovered: \", n_discovered, \"/\", n_total)),\n        div(class = \"overlay-buttons\",\n          actionButton(\"new_game_ov2\", \"Try Again\", class = \"btn-game\")))\n    }\n  })\n\n  # ── Onboarding ──────────────────────────────────────────────────────────\n\n  output$onboarding_ui <- renderUI({\n    if (!isTRUE(gs$show_onboarding)) return(NULL)\n    tc2 <- get_tile_colours(2)\n    tc4 <- get_tile_colours(4)\n    div(class = \"onboarding-overlay\",\n      h3(\"How to Play\"),\n      tags$p(\"Swipe or use arrow keys to slide tiles.\"),\n      tags$p(tags$strong(\"Same colour\"), \" tiles are at the same level and can merge.\"),\n      div(class = \"onboard-hint\",\n        span(class = \"onboard-swatch\", style = paste0(\"background:\", tc2$bg, \";\"), \"DA\"),\n        span(class = \"onboard-plus\", \"+\"),\n        span(class = \"onboard-swatch\", style = paste0(\"background:\", tc2$bg, \";\"), \"5-HT\"),\n        span(class = \"onboard-arrow\", \"\\u2192\"),\n        span(class = \"onboard-swatch\", style = paste0(\"background:\", tc4$bg, \";\"), \"NMDA\")\n      ),\n      tags$p(\"Each new concept must be classified before it joins the board.\"),\n      tags$p(style = \"font-size:0.65rem; opacity:0.6; margin-top:0.3rem;\",\n             \"Hover any tile to see what it is.\"),\n      actionButton(\"dismiss_onboard\", \"Got it!\", class = \"btn-game\",\n                    style = \"margin-top: 0.5rem; padding: 0.5rem 2rem; font-size: 0.9rem;\")\n    )\n  })\n\n  # ── Render Progress ─────────────────────────────────────────────────────\n\n  output$progress_ui <- renderUI({\n    disc <- gs$all_discovered\n    divs <- lapply(all_levels, function(lvl) {\n      lc <- as.character(lvl)\n      total <- nrow(concepts_by_level[[lc]])\n      seen  <- length(disc[[lc]])\n      pct   <- round((seen / total) * 100)\n      tc    <- get_tile_colours(lvl)\n      cat_lbl <- strsplit(concepts_by_level[[lc]]$category[1], \" \")[[1]][1]\n      div(class = \"progress-level\",\n        div(class = \"progress-bar-segment\",\n          div(class = \"progress-bar-fill\",\n              style = paste0(\"width:\", pct, \"%;background:\", tc$bg, \";\"))),\n        div(class = \"progress-category\", cat_lbl),\n        div(class = \"progress-fraction\", paste0(seen, \"/\", total)))\n    })\n    div(class = \"progress-levels\", divs)\n  })\n\n  # ── Discovery Log ───────────────────────────────────────────────────────\n\n  output$discovery_log_ui <- renderUI({\n    if (!isTRUE(gs$log_open)) return(NULL)\n    disc <- gs$all_discovered\n    groups <- lapply(all_levels, function(lvl) {\n      lc <- as.character(lvl)\n      seen_labels <- disc[[lc]]\n      if (is.null(seen_labels) || length(seen_labels) == 0L) return(NULL)\n      tc <- get_tile_colours(lvl)\n      cat_name <- concepts_by_level[[lc]]$category[1]\n      pool <- concepts_by_level[[lc]]\n      items <- lapply(seen_labels, function(sl) {\n        row <- pool[pool$short_label == sl, , drop = FALSE]\n        if (nrow(row) == 0L) return(NULL)\n        div(class = \"discovery-item\",\n          tags$strong(row$label[1]), \" \",\n          span(class = \"disc-tooltip\", paste0(\"- \", row$tooltip[1])))\n      })\n      div(class = \"discovery-level-group\",\n        div(class = \"discovery-level-header\",\n            style = paste0(\"background:\", tc$bg, \"; color:\", tc$fg, \";\"),\n            cat_name),\n        items)\n    })\n    n_discovered <- sum(vapply(disc, length, integer(1)))\n    div(class = \"discovery-content\",\n      div(style = \"font-size:0.65rem; color:#8a8498; margin-bottom:0.4rem;\",\n          paste0(n_discovered, \" of \", nrow(concepts_df), \" concepts discovered\")),\n      Filter(Negate(is.null), groups),\n      if (n_discovered == 0L) div(class = \"discovery-empty\", \"Play to discover concepts!\"))\n  })\n\n  # Toggle arrow direction\n  observe({\n    code <- if (isTRUE(gs$log_open)) \"$('#log-arrow').addClass('open');\"\n            else \"$('#log-arrow').removeClass('open');\"\n    session$sendCustomMessage(type = \"js_eval\", message = code)\n  })\n}\n\nshinyApp(ui, server)\n","type":"text"},{"name":"neuro_concepts.csv","content":"level,label,short_label,tooltip,category\n2,Dopamine,DA,Reward and motivation neurotransmitter,Neurotransmitters\n2,Serotonin,5-HT,Mood and sleep regulation,Neurotransmitters\n2,GABA,GABA,Primary inhibitory neurotransmitter,Neurotransmitters\n2,Glutamate,Glut,Primary excitatory neurotransmitter,Neurotransmitters\n2,Norepinephrine,NE,Arousal and alertness,Neurotransmitters\n2,Acetylcholine,ACh,Learning and muscle activation,Neurotransmitters\n2,Endorphin,Endo,Natural pain relief and pleasure,Neurotransmitters\n2,Oxytocin,OT,Social bonding neuropeptide,Neurotransmitters\n4,NMDA Receptor,NMDA,Glutamate receptor critical for learning,Receptors\n4,GABA-A Receptor,GABA-A,Fast inhibitory receptor,Receptors\n4,D2 Receptor,D2,Dopamine receptor in reward pathways,Receptors\n4,5-HT2A Receptor,5-HT2A,Serotonin receptor in cognition,Receptors\n4,Nicotinic Receptor,nACh,Acetylcholine receptor for fast signalling,Receptors\n4,Mu-Opioid Receptor,Mu-R,Endorphin receptor for pain and reward,Receptors\n4,Adrenergic Receptor,Adren,Norepinephrine receptor for arousal,Receptors\n8,Excitation,Excit,Increasing neural firing probability,Synaptic Processes\n8,Inhibition,Inhib,Decreasing neural firing probability,Synaptic Processes\n8,Reuptake,Reup,Recycling neurotransmitter from synapse,Synaptic Processes\n8,Long-Term Potentiation,LTP,Strengthening synapses through use,Synaptic Processes\n8,Neuromodulation,NMod,Tuning neural circuit sensitivity,Synaptic Processes\n8,Synaptic Pruning,Prune,Eliminating weak connections,Synaptic Processes\n16,Pyramidal Cell,Pyram,Excitatory cortical projection neuron,Cell Types\n16,Interneuron,Inter,Local inhibitory circuit neuron,Cell Types\n16,Purkinje Cell,Purk,Cerebellar coordination neuron,Cell Types\n16,Astrocyte,Astro,Support cell regulating synapses,Cell Types\n16,Motor Neuron,Motor,Neuron driving muscle contraction,Cell Types\n16,Mirror Neuron,Mirror,Fires during action and observation,Cell Types\n32,Reward Circuit,Reward,VTA-to-striatum motivation pathway,Circuits\n32,Fear Circuit,Fear,Amygdala-centred threat response,Circuits\n32,Habit Circuit,Habit,Striatal loop for automatic behaviour,Circuits\n32,Memory Circuit,Memory,Hippocampal encoding pathway,Circuits\n32,Salience Circuit,Salience,Detecting behaviourally relevant stimuli,Circuits\n64,Amygdala,Amyg,Emotion processing and fear learning,Structures\n64,Hippocampus,Hipp,Memory formation and spatial navigation,Structures\n64,Prefrontal Cortex,PFC,Planning and decision-making,Structures\n64,Cerebellum,Cereb,Motor coordination and timing,Structures\n64,Thalamus,Thal,Sensory relay station,Structures\n64,Striatum,Stri,Action selection and reward learning,Structures\n64,Anterior Cingulate,ACC,Conflict monitoring and error detection,Structures\n128,Limbic System,Limbic,Emotion and memory network,Regions\n128,Basal Ganglia,BG,Action selection and habit formation,Regions\n128,Cerebral Cortex,Cortex,Higher cognitive processing,Regions\n128,Brainstem,Stem,Vital functions and arousal,Regions\n128,Temporal Lobe,Temp,Auditory processing and memory,Regions\n256,Default Mode Network,DMN,Self-referential thought and mind-wandering,Networks\n256,Salience Network,SalNet,Switching between internal and external focus,Networks\n256,Central Executive,CEN,Goal-directed attention and working memory,Networks\n256,Frontoparietal Network,FPN,Cognitive control and flexible behaviour,Networks\n512,Motor System,Motor,Planning and executing movement,Systems\n512,Memory System,Memory,Encoding and retrieval of experience,Systems\n512,Attention System,Attn,Selecting and sustaining focus,Systems\n512,Emotion System,Emotion,Generating and regulating affect,Systems\n512,Language System,Lang,Comprehension and production of language,Systems\n1024,Cognition,Cog,Thinking and reasoning processes,Functions\n1024,Perception,Percept,Interpreting sensory information,Functions\n1024,Action,Action,Voluntary behaviour and motor control,Functions\n1024,Affect,Affect,Emotional experience and valuation,Functions\n2048,The Brain,Brain!,The integrated organ of mind and behaviour,The Brain\n","type":"text"}]
